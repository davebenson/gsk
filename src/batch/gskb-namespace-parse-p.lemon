/*
    GSKB - a batch processing framework

    Copyright (C) 2008 Dave Benson

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA

    Contact:
        daveb@ffem.org <Dave Benson>
*/


%include {
#include <string.h>
#include <stdlib.h>
#include "gskb.h"
#include "gskbnamespace-parse.h"

#if G_HAVE_ISO_VARARGS
#define ADD_ERROR(...) g_ptr_array_add (context->errors, g_error_new (GSK_G_ERROR_DOMAIN, GSK_ERROR_PARSE, __VA_ARGS__))
#elif defined(G_HAVE_GNUC_VARARGS)
#define ADD_ERROR(format...) g_ptr_array_add (context->errors, g_error_new (GSK_G_ERROR_DOMAIN, GSK_ERROR_PARSE, format))
#else
#error "no vararg macros"
#endif
}

%token_type {GskbToken *}
%token_prefix {GSKB_TOKEN_TYPE_}
%extra_argument {GskbParseContext *context}

%type opt_name {char *}

%type member {GskbFormatStructMember}
%type member_list {GArray *}

format(RV) ::= INT8.
	{ RV = gskb_format_ref (gskb_format_peek_int8 ()); }
format(RV) ::= INT16.
	{ RV = gskb_format_ref (gskb_format_peek_int16 ()); }
format(RV) ::= INT32.
	{ RV = gskb_format_ref (gskb_format_peek_int32 ()); }
format(RV) ::= INT64.
	{ RV = gskb_format_ref (gskb_format_peek_int64 ()); }
format(RV) ::= UINT8.
	{ RV = gskb_format_ref (gskb_format_peek_uint8 ()); }
format(RV) ::= UINT16.
	{ RV = gskb_format_ref (gskb_format_peek_uint16 ()); }
format(RV) ::= UINT32.
	{ RV = gskb_format_ref (gskb_format_peek_uint32 ()); }
format(RV) ::= UINT64.
	{ RV = gskb_format_ref (gskb_format_peek_uint64 ()); }
format(RV) ::= VINT32.
	{ RV = gskb_format_ref (gskb_format_peek_varlen_int32 ()); }
format(RV) ::= VINT64.
	{ RV = gskb_format_ref (gskb_format_peek_varlen_int64 ()); }
format(RV) ::= VUINT32.
	{ RV = gskb_format_ref (gskb_format_peek_varlen_uint32 ()); }
format(RV) ::= VUINT64.
	{ RV = gskb_format_ref (gskb_format_peek_varlen_uint64 ()); }
format(RV) ::= STRING.
	{ RV = gskb_format_ref (gskb_format_peek_string ()); }

opt_name(NAME) ::= BAREWORD(A).
	{ NAME = g_strdup (A.str); }
opt_name(NAME) ::= .
	{ NAME = NULL; }

opt_extensible(RV) ::= .
	{ RV = FALSE; }
opt_extensible(RV) ::= EXTENSIBLE.
	{ RV = TRUE; }

opt_value(RV) ::= .
	{ RV.has_value = FALSE; }
opt_value(RV) ::= EQUALS INTEGER(I).
	{ RV.has_value = TRUE; RV.value = I.i; }

opt_format(RV) ::= format(A).
	{ RV = A; }
opt_format(RV) ::= .
	{ RV = NULL; }


/* Fixed-length array */
...

/* Length-prefixed array */
...

/* Structures */
member(RV) ::= format(TYPE) BAREWORD(NAME) SEMICOLON.
	{ RV.format = TYPE;
	  RV.name = g_strdup (NAME.str); }
member_list(RV) ::= member(A).
	{ RV = g_array_new (FALSE, FALSE, sizeof (GskbFormatStructMember));
	  g_array_append_val (RV, A); }
member_list(RV) ::= member_list(A) member(B).
	{ RV = A;
	  g_array_append_val (RV, B); }
format(RV) ::= opt_extensible(EXT) STRUCT opt_name(NAME) LBRACE member_list(MEMBERS) RBRACE.
	{ RV = gskb_format_struct_new (NAME, EXT, MEMBERS->len, (GskbFormatStructMember *) MEMBERS->data);
	  g_array_free (MEMBERS, TRUE);
	  g_free (NAME); }

/* Unions */
case_list(RV) ::= .
	{ RV = g_array_new (FALSE, FALSE, sizeof (GskbFormatUnionCase));
case_list(RV) ::= case_list(A) opt_format(TYPE) BAREWORD(NAME) opt_value(V) SEMICOLON.
	{ GskbFormatUnionCase uc;
	  RV = A;
	  uc.format = TYPE;
	  uc.name = NAME.str;
	  if (V.has_value)
	    uc.code = V.value;
	  else if (RV->len == 0)
	    uc.code = 0;
	  else
	    uc.code = g_array_index (RV, GskbFormatUnionCase, RV->len - 1).code + 1; }
format(RV) ::= opt_extensible(EXT) UNION opt_name(NAME) LBRACE case_list(CASES) RBRACE.
  	{ guint i;
	  RV = gskb_format_union_new (NAME, EXT, CASES->len,
				      (GskbFormatUnionCase*)(CASES->data));
          for (i = 0; i < CASES->len; i++)
	    {
	      GskbFormatUnionCase c = g_array_index (CASES, GskbFormatUnionCase, i);
	      if (c->format)
		gskb_format_unref (c->format);
	      g_free (c->name);
	    }
	  g_array_free (CASES, TRUE);
	  g_free (NAME); }

/* Bitfields */
bitfield(RV) ::= BASEWORD(NAME) COLON INTEGER(I) SEMICOLON.
	{ RV.name = g_strdup (NAME.str);
	  RV.length = I.i; }
bitfield_list(RV) ::= .
  	{ RV = g_array_new (FALSE, FALSE, sizeof (GskbFormatBitField)); }
bitfield_list(RV) ::= bitfield_list(A) bitfield(B).
  	{ RV = A;
	  g_array_append_val (RV, B); }
format(RV) ::= BITFIELDS opt_name(NAME) LBRACE bitfield_list(LIST) RBRACE.
	{ RV = gskb_format_bitfields_new (NAME, LIST->len,
					  (GskbFormatBitField *) LIST->data);
          for (i = 0; i < LIST->len; i++)
	    g_free (g_array_index (LIST, GskbFormatBitField, i).name);
	  g_array_free (LIST, TRUE);

/* Enums */
...

/* Alias */
...
