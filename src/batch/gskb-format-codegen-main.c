#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include "gskb-codegen-config.h"
#include "gskb-namespace.h"
#include "../gskutils.h"

static const char *cmdline_input = NULL;

static const char *cmdline_type_prefix = NULL;
static const char *cmdline_func_prefix = NULL;
static const char *cmdline_basename = NULL;
static gboolean cmdline_all_static = FALSE;


static const char *do_not_handedit_warning =
  "/* This file is generated by gskb-format-codegen.\n"
  " * If you edit it, your changes will probably be lost.\n"
  " */\n";

static void
write_buffers_or_die (const char *fname,
                      guint       n_buffers,
                      GskBuffer **buffers)
{
  int fd = open (fname, O_CREAT|O_TRUNC, 0666);
  guint i;
  if (fd < 0)
    g_error ("error creating %s: %s", fname, g_strerror (errno));
  for (i = 0; i < n_buffers; i++)
    {
      while (buffers[i]->size > 0)
        {
          if (gsk_buffer_writev (buffers[i], fd) < 0)
            g_error ("error writing to %s: %s",
                     fname, g_strerror (errno));
        }
    }
  close (fd);
}


static gboolean
handle_prefix (const gchar    *option_name,
               const gchar    *value,
               gpointer        data,
               GError        **error)
{
  GString *tmp;
  const char *at;
  gboolean uc_next;
  cmdline_basename = g_strdup (value);

  /* convert to _ for func_prefix */
  tmp = g_string_new ("");
  for (at = value; *at; at++)
    if (*at == '-')
      g_string_append_c (tmp, '_');
    else
      g_string_append_c (tmp, *at);
  cmdline_func_prefix = g_string_free (tmp, FALSE);

  /* convert - to '' and _ to _ for type_prefix */
  tmp = g_string_new ("");
  uc_next = TRUE;
  for (at = value; *at; at++)
    {
      if (*at == '-')
        {
          uc_next = TRUE;
        }
      else if (*at == '_')
        {
          uc_next = TRUE;
          g_string_append_c (tmp, '_');
        }
      else if (uc_next)
        {
          g_string_append_c (tmp, g_ascii_toupper (*at));
          uc_next = FALSE;
        }
      else
        {
          g_string_append_c (tmp, *at);
        }
    }
  cmdline_type_prefix = g_string_free (tmp, FALSE);

  return TRUE;
}

static GOptionEntry op_entries[] = 
{
  { "input", 'i', 0, G_OPTION_ARG_FILENAME, &cmdline_input,
    "input file containing the formats", "FILE" },
  { "type-prefix", '\0', 0, G_OPTION_ARG_STRING, &cmdline_type_prefix,
    "prefix for generated types", "PREFIX" },
  { "func-prefix", '\0', 0, G_OPTION_ARG_STRING, &cmdline_func_prefix,
    "prefix for generated functions", "PREFIX" },
  { "prefix", '\0', 0, G_OPTION_ARG_CALLBACK, handle_prefix,
    "prefix to generate type- and func- prefix from", "PREFIX_TEMPL" },
  { "all-static", '\0', 0, G_OPTION_ARG_NONE, &cmdline_all_static,
    "generate all functions as static functions", NULL },
  { NULL, '\0', 0, 0, NULL, NULL, NULL }
};

static void
ns_section (GskbNamespace *ns,
            GskbCodegenSection section,
            GskbCodegenConfig *config,
            GskBuffer *output)
{
  guint i;
  for (i = 0; i < ns->n_formats; i++)
    gskb_format_codegen (ns->formats[i], section, config, output);
}

int main(int argc, char **argv)
{
  GOptionContext *op_context;
  GError *error = NULL;
  GskbCodegenConfig *config;
  GskbNamespace *ns;

  op_context = g_option_context_new (NULL);
  g_option_context_set_summary (op_context, "GSKB Code Generator");
  g_option_context_add_main_entries (op_context, op_entries, NULL);
  g_option_context_set_description (op_context,
              "Generating GSKB Formatted Data Manipulation Code");
  if (!g_option_context_parse (op_context, &argc, &argv, &error))
    gsk_fatal_user_error ("error parsing command-line options: %s",
                          error->message);
  g_option_context_free (op_context);

  if (cmdline_type_prefix == NULL)
    gsk_fatal_user_error ("--type-prefix (or --prefix) is required");
  if (cmdline_func_prefix == NULL)
    gsk_fatal_user_error ("--func-prefix (or --prefix) is required");
  if (cmdline_input == NULL)
    gsk_fatal_user_error ("--input is required");

  config = gskb_codegen_config_new (cmdline_type_prefix, cmdline_func_prefix);
  if (cmdline_all_static)
    gskb_codegen_config_set_all_static (config, TRUE);

  /* parse formatted namespace */
  ns = gskb_namespace_new ();
  if (!gskb_namespace_parse_file (ns, cmdline_input, &error))
    gsk_fatal_user_error ("error parsing gskb namespace %s: %s",
                          cmdline_input, error->message);

  /* generate code */
  GskBuffer decls = GSK_BUFFER_STATIC_INIT, impls = GSK_BUFFER_STATIC_INIT;
  gsk_buffer_append_string (&decls, do_not_handedit_warning);
  gsk_buffer_printf (&decls, "\n/* typedefs */\n");
  ns_section (ns, GSKB_CODEGEN_SECTION_TYPEDEFS, config, &decls);
  gsk_buffer_printf (&decls, "\n/* structures */\n");
  ns_section (ns, GSKB_CODEGEN_SECTION_STRUCTURES, config, &decls);
  gsk_buffer_printf (&decls, "\n/* function prototypes */\n");
  ns_section (ns, GSKB_CODEGEN_SECTION_FUNCTION_PROTOTYPES, config, &decls);
  gsk_buffer_printf (&decls, "\n/* format declarations */\n");
  ns_section (ns, GSKB_CODEGEN_SECTION_FORMAT_DECLS, config, &decls);
  gsk_buffer_printf (&decls, "\n/* format private declarations */\n");
  ns_section (ns, GSKB_CODEGEN_SECTION_FORMAT_PRIVATE_DECLS, config, &decls);
  if (!config->all_static)
    {
      gsk_buffer_append_string (&impls, do_not_handedit_warning);
      gsk_buffer_printf (&impls, "#include \"%s.h\"\n\n",
                         cmdline_basename);
    }
  gsk_buffer_printf (&impls, "\n/* format implementations */\n");
  ns_section (ns, GSKB_CODEGEN_SECTION_FORMAT_IMPLS, config, &impls);
  gsk_buffer_printf (&impls, "\n/* function implementations */\n");
  ns_section (ns, GSKB_CODEGEN_SECTION_FUNCTION_IMPLS, config, &impls);
  if (config->all_static)
    {
      char *fname = g_strdup_printf ("%s.include", cmdline_basename);
      GskBuffer *buffers[2] = { &decls, &impls };
      write_buffers_or_die (fname, 2, buffers);
      g_free (fname);
    }
  else
    {
      char *fname;
      GskBuffer *p[1];
      fname = g_strdup_printf ("%s.h", cmdline_basename);
      p[0] = &decls;
      write_buffers_or_die (fname, 1, p);
      g_free (fname);
      fname = g_strdup_printf ("%s.c", cmdline_basename);
      p[0] = &impls;
      write_buffers_or_die (fname, 1, p);
      g_free (fname);
    }

  gskb_codegen_config_free (config);

  return 0;
}
